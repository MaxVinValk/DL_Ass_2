# DL_Ass_2

## Quick start
Get the encoder and decoder networks and unzip them, leaving you with the folders 'enc' and 'dec'. You can load them in on a console using:

```python
from tensorflow import keras

enc = keras.models.load_model(PATH_TO_ENC_FOLDER)
dec = keras.models.load_model(PATH_TO_DEC_FOLDER)
```

From there you can give it any 128 by 128 RGB image. When you give it an image, be certain to reshape it to (1, 128, 128, 3) as per keras requirements.

The 'main' import referred to in various examples below is the 'main' python file in the repository under vae.

### CelebA
If you have the celeba dataset on your computer, you can load one of the images using:

```python
from main import load_celeba

celeba = load_celeba(PATH_TO_CELEBA, 1, (128, 128))

img = next(iter(celeba))

```

Where PATH_TO_CELEBA is the path to the folder that contains the folder with the images (not the folder that has the images itself!).

To show the image:
```python
import numpy as np
from PIL import Image

imgArr = img.numpy()
imgArr = imgArr.reshape(128, 128, 3)
imgArr *= 255
imgArr = imgArr.astype(np.uint8)

Image.fromarray(imgArr).show()

```

To create the latent space vector z, all you have to do is:
```python
_, _, z = enc(img)
```

Which we then can turn into an image:
```python
from main import create_image_from_z

create_image_from_z(dec, z).show()
```

### Alterations
The z that is generated by the encoder can be converted to a numpy array and then manipulated however you please before being turned into an image.

### Face from noise
We can also directly draw a 1 by 50 noise vector and feed it into the decoder directly to create a face, using:
```python
import numpy as np

artificialZ = np.random.normal(0, 1, shape=(1, 50))

```

This can be used just like z in the create_image_from_z function.

### Latent dimension sweep
If you have a z and you want to see what changing one parameter does, you can create a parameter sweep that gives you a list of images each with an increasing value for that dimension. This can be saved as a gif:
```python
from main import create_sweep
from PIL import Image

swp = create_sweep(dec, z, dimension, min, max, step_size)

swp[0].save('out.gif', save_all=True, append_images=swp[1:])

```

Where z has to be a numpy array (if it comes from the encoder, you can turn it into a numpy array using .numpy()), dimension the dimension you want to sweep, min and max the range in which you want to sweep and the step size the size of one step.
